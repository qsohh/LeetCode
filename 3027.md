## Find the Number of Ways to Place People II

这道题因为要求很低，所以$O(n^3)$算法也能直接通过。但是如果题目作为真正的 hard 难度出现的话，应该需要继续优化的。优化到$O(n^2)$的思路非常合理：取消最内侧的`k`循环，记录从`i`开始的、**不超过`yi`的**、最大的`y`（也就是最可能破坏结果的`yk`了）。优化见最下边。

```cpp
class Solution {
public:
    int numberOfPairs(vector<vector<int>>& points) {
        std::sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {return a[0]!=b[0]? a[0]<b[0] : a[1]>b[1];});
        int l = points.size();
        int res = 0;
        for (int i=0; i<l-1; i++) {
            for (int j=i+1; j<l; j++) {
                int xi = points[i][0];
                int yi = points[i][1];
                int xj = points[j][0];
                int yj = points[j][1];
                if (yi >= yj) {
                    bool flag = true;
                    for (int k=i+1; k<j; k++) {
                        int xk = points[k][0];
                        int yk = points[k][1];
                        if ((yi >= yk) && (yk >= yj)) {
                            flag = false;
                            break;
                        }
                    }
                    if (flag) {res++;}
                }
            }
        }
        return res;
    }
};
```

```cpp
class Solution {
public:
    int numberOfPairs(vector<vector<int>>& points) {
        std::sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {return a[0]!=b[0]? a[0]<b[0] : a[1]>b[1];});
        int l = points.size();
        int res = 0;
        for (int i=0; i<l-1; i++) {
            int yk = -1000000001;
            const int yi = points[i][1];
            for (int j=i+1; j<l; j++) {
                const int yj = points[j][1];
                if (yi >= yj && yj > yk) {
                    res++;
                    yk = yj;
                }
            }
        }
        return res;
    }
};
```