## Maximum Width Ramp

最初想法是单调栈+二分（维护一个严格递减单调栈，每当遇到一个有可能构成ramp的右端点时，向左二分查找到最优左端点）。但是可以优化成$O(n)$，先构造单调栈，再从右向左扫描，遇到小的就出栈（因为更靠左的右端点不会比先遇到的右端点更好）。

```python
class Solution:
    def maxWidthRamp(self, nums: List[int]) -> int:
        st = [[-nums[0], 0]]
        res = 0
        for i, n in enumerate(nums[1:], 1):
            top, idx = -st[-1][0], st[-1][1]
            if top > n:
                st.append([-n, i])
            elif top == n:
                res = max(res, i - idx)
            else:
                # binary search
                get_data = bisect_left(st, [-n, -1])
                idx = st[get_data][1]
                res = max(res, i - idx)
        return res
```

```cpp
class Solution {
public:
    int maxWidthRamp(vector<int>& nums) {
        std::vector<int> st{0};
        int l = nums.size();
        for (int i=1; i<l; i++) {
            int top = nums[st.back()];
            if (top > nums[i]) {st.push_back(i);}
        }
        int res = 0;
        for (int i=l-1; i>-1; i--) {
            while (nums[st.back()] <= nums[i]) {
                res = max(res, i - st.back());
                st.pop_back();
                if (st.empty()) {return res;}
            }
        }
        return res; // 这个return貌似是不会到的
    }
};
```