## 01 Matrix

Multi-source BFS版本：
```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])
        res = mat
        queue = deque()
        visited = set()
        for i, j in product(range(m), range(n)):
            if not mat[i][j]:
                queue.append((i, j))
                visited.add((i, j))

        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        cur_distance = 0

        while queue:
            cur_distance += 1
            for _ in range(len(queue)):
                y, x = queue.popleft()
                for dy, dx in directions:
                    if (0<=y+dy<m) and (0<=x+dx<n) and ((y+dy, x+dx) not in visited):
                        res[y+dy][x+dx] = cur_distance
                        queue.append((y+dy, x+dx))
                        visited.add((y+dy, x+dx))
        return res
```

同时，发现了```set```还能这么用 ：

```python
visited = set()
visited |= {(3, 5)}
```

```|=```中的```|```是算赋OR，两个```set```之间用这个算赋相当于是相加（很秀，但是我还是直接写```.add(element)```吧……

本来自己写的那个改完的版本 ：

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])
        res = [[m+n+1 if mat[i][j] else 0 for j in range(n)] for i in range(m)]
        st = set()
        for i in range(m):
            for j in range(n):
                if mat[i][j]:
                    st.add((i, j))
        cur_distance = 0
        while st:
            cur_distance += 1
            stt = st.copy()
            for x, y in st:
                mx = m+n+1
                if m == 1:
                    pass
                elif x == 0:
                    mx = min(mx, res[x+1][y]+1)
                elif x == m-1:
                    mx = min(mx, res[x-1][y]+1)
                else:
                    mx = min(mx, res[x-1][y]+1, res[x+1][y]+1)
                if n == 1:
                    pass
                elif y == 0:
                    mx = min(mx, res[x][y+1]+1)
                elif y == n-1:
                    mx = min(mx, res[x][y-1]+1)
                else:
                    mx = min(mx, res[x][y-1]+1, res[x][y+1]+1)
                if mx <= m+n:
                    res[x][y] = mx
                    if mx < cur_distance:
                        stt.remove((x, y))
            st = stt.copy()
        return res
```
