## Beautiful Array

奇数一组偶数一组，之后每组数里边再分奇偶两组（按(i+1)/2与i/2来分），分治之后就能确保怎么找ijk都不会找出来ij在同一组里了。

可以用装饰器```@lru_cache()```来缓存：
```python
class Solution:
    @lru_cache()
    def beautifulArray(self, n: int) -> List[int]:
        if n == 1:
            return [1]
        if n%2:
            return [i*2-1 for i in self.beautifulArray(n//2+1)] + [i*2 for i in self.beautifulArray(n//2)]
        if not n%2:
            return [i*2-1 for i in self.beautifulArray(n//2)] + [i*2 for i in self.beautifulArray(n//2)]
```

**问题 ：** 是不是有了这个装饰器，以后做动态规划的时候，是不是就只需要写出第推关系，不需要用脑子思考怎么储存了？

有个大佬直接这么搞的：
```python
class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        ## 性质一：漂亮数组线性变换后依然是漂亮数组
        ## 性质二：奇数漂亮数组和偶数漂亮数组合并后，依然是漂亮数组
        res = [1]
        while len(res) < n:
            t = []
            for num in res:
                if 2 * num - 1 <= n:
                    t.append(2 * num - 1)
            for num in res:
                if 2 * num <= n:
                    t.append(2 * num)
            res = t[:]
        return res
```

事实上，直接从底层向上构成漂亮数组，显然是个更快捷更直接的解法（```2*num<=n```这两步就是在确保最后的结果里边不包含超过n的），同时，大佬里边还可以加一个性质三：漂亮数组中去掉任意元素之后依然是漂亮数组。

直接组成完整数组之后再分治也会更快：
```python
class Solution:
    def beautifulArray(self, n: int) -> List[int]:
        L = list(range(1, n + 1))
        def helper(L):
            if len(L)<3:
                return L
            even = L[::2]
            odd = L[1::2]
            return helper(even) + helper(odd)
        return helper(L)
```
