## Find the Minimum Area to Cover All Ones II

现在这是平平无奇的枚举，可是这方法也太蠢了，这么做的话，实在不像是hard难度的题。这道题在这个情形下，六种分割方法的枚举应该是不可避免的，但是可以通过前置计算**用DP计算\[左上角为`0, 0`，右下角为`(i, j)`的子矩形的覆盖所有`1`的最小矩形面积\]**，然后就可以在枚举中使用$O(1)$复杂度查表给出结果了。

```python
class Solution:
    def __init__(self):
        self._mem = {}

    def h(self, a: int, b: int, c: int, d: int) -> int:
        if (a, b, c, d) in self._mem:
            return self._mem[(a, b, c, d)]
        t = b + 1
        f = a
        l = d + 1
        r = c
        for i in range(a, b+1):
            for j in range(c, d+1):
                if self.grid[i][j]:
                    t = min(t, i)
                    f = max(f, i)
                    l = min(l, j)
                    r = max(r, j)
        res = (f + 1 - t) * (r + 1 - l)
        self._mem[(a, b, c, d)] = res
        return res

    def minimumSum(self, grid: List[List[int]]) -> int:
        self.grid = grid
        m = len(grid)
        n = len(grid[0])
        self.m = m
        self.n = n
        res = m * n
        for i in range(m-1):
            for j in range(n-1):
                res = min(res, self.h(0, i, 0, n-1)+self.h(i+1, m-1, 0, j)+self.h(i+1, m-1, j+1, n-1))
                res = min(res, self.h(0, i, 0, j)+self.h(0, i, j+1, n-1)+self.h(i+1, m-1, 0, n-1))
                res = min(res, self.h(0, m-1, 0, j)+self.h(0, i, j+1, n-1)+self.h(i+1, m-1, j+1, n-1))
                res = min(res, self.h(0, i, 0, j)+self.h(i+1, m-1, 0, j)+self.h(0, m-1, j+1, n-1))
        for i1 in range(m-2):
            for i2 in range(i1+1, m-1):
                res = min(res, self.h(0, i1, 0, n-1)+self.h(i1+1, i2, 0, n-1)+self.h(i2+1, m-1, 0, n-1))
        for j1 in range(n-2):
            for j2 in range(j1+1, n-1):
                res = min(res, self.h(0, m-1, 0, j1)+self.h(0, m-1, j1+1, j2)+self.h(0, m-1, j2+1, n-1))
        return res
```