这道题需要用Mo's algorithm，用prefix count是会TLE的。

更复杂的数据结构（如wavelet tree），是有可能能做的，但是估计会MLE。
```Python
class Solution:
    def subarrayMajority(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        NN = len(nums)
        NQ = len(queries)
        block_size = int(sqrt(NN))+1
        sq = sorted([(l, r, t, idx) for idx, (l, r, t) in enumerate(queries)], key=lambda x: (x[0]//block_size, x[1] if (x[0]//block_size)%2 else -x[1]))

        cl, cr = 0, 0
        ct = Counter([nums[0]])
        res = [0]*NQ
        for l, r, t, idx in sq:
            while cr > r:
                ct[nums[cr]] -= 1
                if ct[nums[cr]] == 0:
                    del ct[nums[cr]]
                cr -= 1
            while cr < r:
                cr += 1
                ct[nums[cr]] += 1
            while cl < l:
                ct[nums[cl]] -= 1
                if ct[nums[cl]] == 0:
                    del ct[nums[cl]]
                cl += 1
            while cl > l:
                cl -= 1
                ct[nums[cl]] += 1
            cur_n, cur_fre = -1, 0
            for n, fre in ct.items():
                if fre >= t:
                    if fre > cur_fre:
                        cur_n = n
                        cur_fre = fre
                    if fre == cur_fre:
                        cur_n = min(cur_n, n)
            res[idx] = cur_n
        return res
```

有个大佬估计提前用的Mo's的模板：

```Python
import collections
import math

class Solution:
  def subarrayMajority(self, nums: list[int], queries: list[list[int]]) -> list[int]:
    n = len(nums)
    q = len(queries)
    block_size = int(math.sqrt(n))
    
    jurnavalic = []
    for i, query in enumerate(queries):
        jurnavalic.append((query[0], query[1], query[2], i))
    
    jurnavalic.sort(key=lambda x: (x[0] // block_size, x[1]))
    
    ans = [0] * q
    
    freq = collections.Counter()
    current_l, current_r = 0, -1
    
    def add(index):
        nonlocal freq
        freq[nums[index]] += 1
        
    def remove(index):
        nonlocal freq
        freq[nums[index]] -= 1
        if freq[nums[index]] == 0:
            del freq[nums[index]]

    def find_best_element(threshold):
        best_element = -1
        max_freq = 0
        
        for num, count in freq.items():
            if count >= threshold:
                if count > max_freq:
                    max_freq = count
                    best_element = num
                elif count == max_freq:
                    best_element = min(best_element, num)
        return best_element

    for l, r, threshold, original_idx in jurnavalic:
        while current_l > l:
            current_l -= 1
            add(current_l)
        while current_r < r:
            current_r += 1
            add(current_r)
        while current_l < l:
            remove(current_l)
            current_l += 1
        while current_r > r:
            remove(current_r)
            current_r -= 1
        
        ans[original_idx] = find_best_element(threshold)

    return ans
```
学习了，学习了
