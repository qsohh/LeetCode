## Minimum Cost Path with Teleportations

一开始想法是dp，然后觉得dp之后传送的地方没法处理，于是考虑Dijkstra。

但是Dijkstra有以下是需要特别注意的，不然很容易TLE或者MLE：
- 注意提前剪枝；
- 用一个三维数组`dist[i][j][k]`用来存储`k`次传送到某个坐标的费用（相当于是Dijkstra的最小堆控制规划方向的dp）；
- 剪枝只用一个或者两个`set`来存储坐标肯定是不够的，至少要像这样用`idx_at_tele`来记录当前传送层已经传到的最大数值位置（因为既然已经传送到$v$了，那再用相同或更多的层数传到比$v$还小的数值位置显然是没必要的。

还有个需要注意的小点是，更新`set[tuple]`的时候，要用`visited |= {(i, j)}`或者`visited.add((i, j))`，不能用`visited |= set((i, j))`。

```python
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        d = defaultdict(list)
        m = len(grid)
        n = len(grid[0])
        for i in range(m):
            for j in range(n):
                d[grid[i][j]].append((i, j))
        vals = sorted(list(d.keys()))
        val_idx = {v: idx for idx, v in enumerate(vals)}

        dist = [[[float('Inf')]*(k+1) for _ in range(n)] for _ in range(m)]
        dist[0][0][0] = 0
        hq = [(0, 0, 0, 0)] # cost, idx_i, idx_j, nb_teleport
        idx_at_tele = [-1] * k
        while hq:
            cur_cost, i, j, nt = heapq.heappop(hq)
            if cur_cost > dist[i][j][nt]:
                continue
            if i == m-1 and j == n-1:
                return cur_cost
            # standard jump
            if i+1 != m:
                if cur_cost+grid[i+1][j] < dist[i+1][j][nt]:
                    for idxt in range(nt, k+1):
                        dist[i+1][j][idxt] = cur_cost+grid[i+1][j]
                    heapq.heappush(hq, (cur_cost+grid[i+1][j], i+1, j, nt))
            if j+1 != n:
                if cur_cost+grid[i][j+1] < dist[i][j+1][nt]:
                    for idxt in range(nt, k+1):
                        dist[i][j+1][idxt] = cur_cost+grid[i][j+1]
                    heapq.heappush(hq, (cur_cost+grid[i][j+1], i, j+1, nt))
            # teleport to a cell has not been visited with no teleport
            if nt < k:
                pos = val_idx[grid[i][j]]
                cur = idx_at_tele[nt]+1
                while cur <= pos:
                    val = vals[cur]
                    for ti, tj in d[val]:
                        if (ti, tj) != (i, j) and cur_cost < dist[ti][tj][nt+1]:
                            for idxt in range(nt+1, k+1):
                                dist[ti][tj][idxt] = cur_cost
                            heapq.heappush(hq, (cur_cost, ti, tj, nt+1))
                    cur += 1
                idx_at_tele[nt] = max(pos, idx_at_tele[nt])

```

考虑到这道题的情景，普通移动是只允许向右、向下移动的，加上传送次数只加不减所以是个有向无环图 directed acyclic graph (DAG)，可以用更加优化的dp：
- 每层计算过程中直接准备更新postfix_min；
- 对于每层nt来说，只创建一维数组滚动逐行计算。

实际上我这个`postfix_min`的更新过程还可以更优化，两个`.copy()`貌似是没必要的。

```python
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        m = len(grid)
        n = len(grid[0])
        vals = sorted({x for row in grid for x in row})
        q = len(vals)
        val_idx = {v: idx for idx, v in enumerate(vals)}

        postfix_min = [float('Inf')] * len(vals)
        # iterate along each teleport level
        for nt in range(k+1):
            # rolling dp for each row
            h = [-grid[0][0]] +  [float('Inf')] * n # last Inf value prepared for j = 0
            # set postfix min
            prepare_postfix = postfix_min.copy()
            for i, row in enumerate(grid):
                for j, v in enumerate(row):
                    # normal move from current level
                    h[j] = min(h[j] + grid[i][j], h[j-1] + grid[i][j])
                    # teleported from postfix min
                    h[j] = min(h[j], postfix_min[val_idx[grid[i][j]]])
                    # prepare for update postfix min
                    prepare_postfix[val_idx[grid[i][j]]] = min(prepare_postfix[val_idx[grid[i][j]]], h[j])
            # update postfix min
            cur_min = prepare_postfix[-1]
            for idx in range(q-1, -1, -1):
                cur_min = min(cur_min, prepare_postfix[idx])
                prepare_postfix[idx] = cur_min
            postfix_min = prepare_postfix.copy()
        return h[-2]
```