## Maximum Good Subarray Sum

简单记录所有`val`对应的`idx`再针对`n+k`与`n-k`的所有`idx`都遍历一遍是$O(n^2)$，会超时的。可以直接在计算前缀和的同时就**这个位置以前**的所有值是`n+k`或`n-k`的坐标里的**最小和**做计算，然后再更新前缀和和`pre_besti`（以保证只会搜索此前的局部最小值，而且不需要额外存储）。这样复杂度就是$O(n)$了。

```python
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        pre = [0]
        pre_besti = {}
        res = -float("inf")
        for i, n in enumerate(nums):
            pre.append(pre[-1] + n)
            if n+k in pre_besti:
                res = max(res, pre[i+1] - pre_besti[n+k])
            if n-k in pre_besti:
                res = max(res, pre[i+1] - pre_besti[n-k])
            if n not in pre_besti:
                pre_besti[n] = pre[i]
            else:
                pre_besti[n] = min(pre_besti[n], pre[i])
        return res if res > -float("inf") else 0
```