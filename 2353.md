## Design a Food Rating System

注意这里有个很常用但是好几次都没注意到的技巧：进栈/堆的数据在需要修改的时候不需要在栈/堆里边真的完成修改，可以在出栈/堆的时候再检查是否是有效数据。如果有效，采用；无效则忽视并继续出栈/堆。

同时，对于C++来说，以后遇到这种问题可以使用`map`的`key`是有序的（$O(log(n))$）这一特点来给每个类别里针对每个rating来分桶。

总之，需要记住的两点：
- 懒删除
- 分桶

```cpp
class FoodRatings {
private:
    struct FoodComp {
        bool operator()(const std::pair<int, std::string>& a, const std::pair<int, std::string>& b) const {
            return a.first == b.first? a.second > b.second : a.first < b.first;
        }
    };

    using FoodPair = std::pair<int, std::string>;
    using FoodPQ = std::priority_queue<FoodPair, std::vector<FoodPair>, FoodComp>;

    std::unordered_map<std::string, int> _r;
    std::unordered_map<std::string, std::string> _c;
    std::unordered_map<std::string, FoodPQ> _d;

public:
    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {
        for (int i=0; i<foods.size(); i++) {
            _r[foods[i]] = ratings[i];
            _c[foods[i]] = cuisines[i];
            _d[cuisines[i]].push(FoodPair{ratings[i], foods[i]});
        }
    }

    void changeRating(string food, int newRating) {
        std::string c=_c[food];
        _d[c].push(FoodPair{newRating, food});
        _r[food] = newRating;
    }

    string highestRated(string cuisine) {
        while (_d[cuisine].top().first != _r[_d[cuisine].top().second]) {
            _d[cuisine].pop();
        }
        return _d[cuisine].top().second;
    }
};

/**
 * Your FoodRatings object will be instantiated and called as such:
 * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);
 * obj->changeRating(food,newRating);
 * string param_2 = obj->highestRated(cuisine);
 */
```

```python
class FoodRatings:
    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):
        self.d = defaultdict(list)
        self.r = {}
        self.l = {}
        n = len(foods)
        for i in range(n):
            heapq.heappush(self.d[cuisines[i]], [-ratings[i], foods[i]])
            self.r[foods[i]] = ratings[i]
            self.l[foods[i]] = cuisines[i]

    def changeRating(self, food: str, newRating: int) -> None:
        heapq.heappush(self.d[self.l[food]], [-newRating, food])
        self.r[food] = newRating
        return

    def highestRated(self, cuisine: str) -> str:
        while -self.d[cuisine][0][0] != self.r[self.d[cuisine][0][1]]:
            heapq.heappop(self.d[cuisine])
        return self.d[cuisine][0][1]

# Your FoodRatings object will be instantiated and called as such:
# obj = FoodRatings(foods, cuisines, ratings)
# obj.changeRating(food,newRating)
# param_2 = obj.highestRated(cuisine)
```