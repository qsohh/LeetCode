## Maximum Walls Destroyed by Robots

这题作为hard来说还挺简单的。再优化可以考虑一下对于每个机器人预先把几个标志坐标的二分算出来（比如`r`，固定需要算的，就不用放到`cnt_walls()`里边每调用一次都额外两个二分了）。

```python
class Solution:
    def cnt_walls(self, l, r):
        return bisect_right(self.walls, r) - bisect_left(self.walls, l)

    def maxWalls(self, robots: List[int], distance: List[int], walls: List[int]) -> int:
        self.walls = walls
        dp = [0, 0]
        nr = len(robots)
        nw = len(walls)
        rd = [(0, 0)] + sorted([(robots[i], distance[i]) for i in range(nr)]) + [(1e9+1, 0)]
        walls.sort()
        for i, (r, d) in enumerate(rd[1:-1], 1):
            # current fires at +
            p = self.cnt_walls(r, min(r+d, rd[i+1][0]-1))
            # prev fired at +, current fires at -
            pn = self.cnt_walls(max(r-d, min(rd[i-1][0]+rd[i-1][1]+1, r)), r)
            # prev fired at -, current fires at -
            nn = self.cnt_walls(max(r-d, rd[i-1][0]+1), r)
            dp = [max(dp[0] + p, dp[1] + p), max(dp[0] + pn, dp[1] + nn)]
        return max(dp)
```