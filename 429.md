## N-ary Tree Level Order Traversal

反正是广搜，写出来差别不大……不过我自己写的这个确实稍微有点累赘：

```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return []
        res, level = [[root.val]], 0
        queue = deque()
        queue.append([root, 0])
        while queue:
            cur, cur_level = queue.popleft()
            if cur_level == level and cur.children:
                res.append([])
                level += 1
            for ele in cur.children:
                queue.append([ele, level])
                res[level].append(ele.val)
        return res
```

稍微简洁一点可以这样：对每一层里边写个```for```，按照队列中现有元素个数来区分每一层

```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return []
        queue = deque([root])
        res = []
        
        while queue:
            lst = []
            for _ in range(len(queue)):
                node = queue.popleft()
                lst.append(node.val)
                for ele in node.children:
                    queue.append(ele)
            res.append(lst)
        return res
```

有个大佬用 list comprehension 是这么写的：

```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        
        queue = [root]
        while any(queue):
            
            res.append([node.val for node in queue])
            queue = [child for node in queue for child in node.children]
        return res
```

对于两层循环的 list comprehension，大佬是这么解释的：

```python
# List Comprehension 
[word for sentence in text for word in sentence]
```
