## Find Stores with Inventory Imbalance

```python
import pandas as pd

def find_inventory_imbalance(stores: pd.DataFrame, inventory: pd.DataFrame) -> pd.DataFrame:
    d = inventory.groupby(["store_id"])["product_name"].nunique()
    valid_ids = d[d>=3].index
    inventory = inventory[inventory["store_id"].isin(valid_ids)]
    max_price = inventory.sort_values(["store_id", "price", "quantity"], ascending=[True, False, False]).groupby(["store_id"], as_index=False).first()
    min_price = inventory.sort_values(["store_id", "price", "quantity"], ascending=[True, True, False]).groupby(["store_id"], as_index=False).first()
    merge = pd.merge(max_price, min_price, on="store_id", suffixes=("_expe", "_cheap"))
    merge = merge[merge["quantity_expe"] < merge["quantity_cheap"]]
    merge["imbalance_ratio"] = (merge["quantity_cheap"] / merge["quantity_expe"]).round(2)
    result = pd.merge(merge, stores, on="store_id")
    result.rename(columns={"product_name_expe": "most_exp_product", "product_name_cheap": "cheapest_product"}, inplace=True)
    result = result[["store_id", "store_name", "location", "most_exp_product", "cheapest_product", "imbalance_ratio"]]
    return result.sort_values(["imbalance_ratio", "store_name"], ascending=[False, True]).reset_index(drop=True)
```

```postgreSQL
-- Write your PostgreSQL query statement below
WITH
    valid_stores AS (
        SELECT store_id
        FROM inventory
        GROUP BY store_id
        HAVING COUNT(DISTINCT product_name) >= 3
    ),
    inv AS (
        SELECT store_id, product_name, quantity, price
        FROM inventory
        JOIN valid_stores USING (store_id)
    ),
    ranked_most AS (
        SELECT store_id, product_name AS most_exp_product, quantity AS expe_qtt, price AS expe_price,
            ROW_NUMBER() OVER(
                PARTITION BY store_id
                ORDER BY price DESC, quantity DESC
            ) AS most_expe
        FROM inv
    ),
    ranked_cheap AS (
        SELECT store_id, product_name AS cheapest_product, quantity AS cheap_qtt, price AS cheap_price,
            ROW_NUMBER() OVER(
                PARTITION BY store_id
                ORDER BY price ASC, quantity DESC
            ) AS cheap
        FROM inv
    ),
    expe AS (
        SELECT store_id, most_exp_product, expe_qtt
        FROM ranked_most
        WHERE most_expe = 1
    ),
    chp AS (
        SELECT store_id, cheapest_product, cheap_qtt
        FROM ranked_cheap
        WHERE cheap = 1
    ),
    assemble AS (
        SELECT store_id, most_exp_product, expe_qtt, cheapest_product, cheap_qtt,
            ROUND(cheap_qtt::numeric / expe_qtt, 2) AS imbalance_ratio
        FROM expe
        JOIN chp USING (store_id) WHERE expe_qtt < cheap_qtt
    )
SELECT store_id, store_name, "location", most_exp_product, cheapest_product, imbalance_ratio
FROM assemble
JOIN stores USING (store_id)
ORDER BY imbalance_ratio DESC, store_name ASC;
```