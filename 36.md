## Valid Sudoku

基础版解法 ：

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        def check_unit(lst):
            numbers = [ele for ele in lst if ele != '.']
            st = set(numbers)
            if len(st) != len(numbers):
                return False
            return True
        for row in board:
            if not check_unit(row):
                return False
        for i in range(9):
            if not check_unit([row[i] for row in board]):
                return False
        for i in range(3):
            for j in range(3):
                if not check_unit(board[i*3][j*3:j*3+3]+board[i*3+1][j*3:j*3+3]+board[i*3+2][j*3:j*3+3]):
                    return False
        return True
```

大佬写的更简洁的代码 ： 

其中，```zip(*board)```实际上就是```board```的转置。而两组```product```可以更快得组合出几个分块。

```python
class Solution:
    def isValidSudoku(self, board):
        for row in chain(board, zip(*board)):
            cand = [i for i in row if i != "."]
            if len(set(cand)) != len(cand): return False
            
        for x, y in product([1,4,7],[1,4,7]):
            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]
            cand = [i for i in cand if i != "."]
            if len(set(cand)) != len(cand): return False
        
        return True
```

更快的办法可以直接对每个小单元把元素记下来，然后扫过去的时候来看每个单元里边是否已经有了 ：

（本来以为这样会占用更多空间，但是实际上几乎没有变化）

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        boxes = [set() for _ in range(9)]
        
        for i, j in product(range(9), range(9)):
            number = board[i][j]
            if number == '.':
                continue
            if number in rows[i]:
                return False
            else:
                rows[i].add(number)
            if number in cols[j]:
                return False
            else:
                cols[j].add(number)
            box_ind = i//3*3 + j//3
            if number in boxes[box_ind]:
                return False
            else:
                boxes[box_ind].add(number)
        return True
```
